### 최대공약수 구하는 법
import math
A, B = 10, 20
print(math.gcd(A, B))
 --> 10

### 소숫점 나태나는 법
round(a,b)
 -> a라는 숫자를 소수점 b자리가 남도록 반오림

### 파이썬 입력 빨리 받기
import sys
num = int(sys.stdin.readline().rstrip())

### 이중 리스트 정렬 하기
birthdays.sort(key = lambda x: (x[1], x[2], x[3]))


# 20230726

### 카운팅 정렬 -> 시간 복잠도 O(N)으로 매우 짧은 편  ###백준 10989
#### 기존 .sort() 메서드의 시간 복잡도는 O(N^2)
##### 작동 방식
  - 배열을 이용한 방식
    - 배열에 존재하는 수의 개수를 세어주고, 이 정보를 바탕으로 정렬을 수행.
    - 수의 개수는 배열 혹은 딕셔너리의 인덱스와 해당 값을 통해서 기록.
    - 배열을 통한 계수 정렬 -> 누적합의 개념을 적용
      1. 배열에 존재하는 값의 각 원소의 개수를 세어줄 새로운 배열 count를 만들어 줌.
          - count의 길이는 원소의 최대값까지를 인덱스로 사용할 수 있도록 원소의 최대값 + 1 만큼으로 정해준다.
          - count[i]는 숫자 i가 배열에 몇개 존재하는지에 대한 정보를 담는다.
            ```py
            # 정렬을 수행할 배열
            arr = [4, 7, 9, 1, 3, 5, 2, 3, 4]

            count = [0] * (max(arr) + 1)

            for num in arr:
              count[num += 1]

            print(count)
            ```
      2. count 배열의 원소를 누적합 값으로 갱신해 줌. 이 작업은 arr에 담긴 원로를 바로 정렬된 위치로 삽입하기 위한 사전작업